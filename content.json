{"pages":[{"title":"","text":"个人信息：软件工程专业","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Java设计模式","text":"一 、七大原则核心思想： 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起 针对接口编程 为了交互对象之间的松耦合设计努力 单一职责原则 1.降低类的复杂度 一个类只负责一个职责（如果类的功能特别复杂） 2.降低变更风险 只有逻辑足够简单才可以违背单一职责原则 只有类中方法数量足够少，才可以在方法级别保持单一职责原则 隔离接口原则将一个接口按照需求分为多个接口 依赖倒转原则高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。 抽象不应该依赖于具体，具体应该依赖于抽象 变量的申明类型尽量是抽象类或者接口，这样我们变量引用和实际对象间就存在一个缓冲间，利于程序的拓展和优化。 里氏替换原则解决继承带来的入侵性 引用一个基类将原来的继承关系去掉，在通过组合聚合的方式解决 开闭原则对提供方扩展开放 对使用方修改关闭 用一个抽象类 通过子类继承并重写抽象方法的方式来实现 迪米特原则也叫最少知道原则 对自己依赖的类知道的越少越好 直接的朋友 避免陌生的类以局部变量的形式出现在类的内部 合成复用原则尽量使用聚合或合成 少用继承 本文到此结束 感谢相遇 (●’◡’●)","link":"/2020/02/20/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"单链表练习","text":"1.有关单链表的练习(新浪)1234567891011121314151617181920212223242526/*查找倒数第K个节点*/public void getKnode(Node head, int k) { if (head.next == null){ System.out.println(\"链表为空!\"); return; } //首先得到整个单链表的有效节点数 int sum = getsize(head); if (k&lt;=0||sum &lt; k) { System.out.println(\"找不到该节点\"); return; } Node temp = head.next; //刚好等于第一个 if (sum == k) { System.out.println(temp); } else { int num = 0; while (num!=(sum-k)) { num++; temp = temp.next; } System.out.println(temp); }} 2.单链表反转(腾讯)12345678910111213141516171819202122/*链表反转*/public void ReverseList(Node head){ //1.创建一个辅助头节点 //2.每遍历出一个节点,便让该节点指向辅助头节点的下一个节点 然后头节点指向该节点 if (head.next == null){ System.out.println(\"空链表!!!\"); } Node temp = head.next;//辅助节点 Node temp1 = null;//保存辅助节点(当前遍历出的节点)的next Node newhead = new Node(0,\"\"); while (temp!= null){ //1.先保存前遍历出的节点的next temp1 = temp.next;//不保存的话 辅助指针无法后移 //2.遍历出来的节点指向新头节点的第一个节点 temp.next = newhead.next; //3.新头节点指向遍历出来的节点 newhead.next = temp; //4.指针后移 temp = temp1; } head.next = newhead.next;} 3.将链表从尾到头打印(百度)123456789101112131415161718public void ReversePrint(Node head){ //每遍历出一个节点便压出栈,最后遍历栈即可 if (head.next == null){ System.out.println(\"空链表\"); } //ctrl + alt + v 快速生成 Stack&lt;Node&gt; nodestack = new Stack&lt;&gt;();//创建一个栈 Node temp = head.next; while (temp!=null){//入栈 nodestack.push(temp); temp = temp.next;//后移 } //出栈 while(nodestack.size()&gt;0){ System.out.println(nodestack.pop()); }} 4.合并两个有序的单链表12345678910111213141516171819/*合并2个有序单链表后仍然有序*/public Node uniteList(Node head1, Node head2) { //递归出口(直到另一方为空后直接接上) if (head1 == null) { return head2; } if (head2 == null) { return head1; } //小的一方移动,然后递归 最后返回第一个最小的节点 if (head1.no &lt;= head2.no) { head1.next = uniteList(head1.next, head2); return head1; } else { head2.next = uniteList(head1, head2.next); return head2; }} 本文到此结束 感谢相遇 (●’◡’●)","link":"/2020/02/29/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0/"},{"title":"数组模拟队列","text":"方式一:普通队列 这种方式数组只是使用一次 123456789101112private int front;//模拟头指针private int rear;//模拟尾指针private int Maxsize;//模拟队列最大容量private int[] array;//模拟队列存放数据 //构造方法初始化数组 public ArrayQueueDemo(int maxsize) { this.front = -1;//指向队列头元素的前一个 this.rear = -1; //指向队列的最后一个元素 Maxsize = maxsize; this.array = new int[Maxsize]; } 栈满的条件:front == rear 栈空的条件:rear == Maxsize - 1; 入队: 12345678public void addQueue(int n) { if (isFull()) { System.out.println(&quot;队列已满&quot;); return; } rear++;//尾指针后移 array[rear] = n;//把元素放进数组} 出队: 1234567public int getQueue() { if (isEmpty()) { throw new RuntimeException(&quot;队列为空!!&quot;); } front++;//后移一位 return array[front];//取出数据} 方式二(改进):环形此种方式改变front和rear的定义来实现环形队列,但是必须牺牲一个空间. 也就是说一开始设立的数组永远不能装满 栈满的条件:(rear+1)%Maxsize == front 栈空的条件:front == rear 出队: 123456789/*出队列*/public int getQueue() { if (isEmpty()) { throw new RuntimeException(&quot;队列为空!!&quot;); } int value = array[front]; front = (front+1)%Maxsize;//取模后 每次取到队列最后一个时,便会从0开始取 return value;//取出数据} 入队: 12345678910/*向队列添加元素(入队列)*/public void addQueue(int n) { if (isFull()) { System.out.println(&quot;队列已满&quot;); return; } array[rear] = n;//把元素放进数组 System.out.println(&quot;rear=&quot;+rear+&quot;n:&quot;+n); rear = (rear+1)%Maxsize;//取模后 每次队列满的时候,取出后,下次再存便是从0开始} 完整队列类代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Circlequeue{ private int front;//指向队列第一个元素 private int rear;//指向队列最后一个有效元素的后一个位置(始终是空的) private int Maxsize;//模拟队列最大容量 private int[] array;//模拟队列存放数据 //初始化 public Circlequeue(int maxsize) { this.front = 0;//不写也可以 默认为零 this.rear = 0; // Maxsize = maxsize; array = new int[Maxsize]; } /*判断队列是否为空*/ public boolean isEmpty() { return front == rear; } /*判断队列是否满*/ public boolean isFull() { return (rear+1)%Maxsize == front; } /*向队列添加元素(入队列)*/ public void addQueue(int n) { if (isFull()) { System.out.println(\"队列已满\"); return; } array[rear] = n;//把元素放进数组 System.out.println(\"rear=\"+rear+\"n:\"+n); rear = (rear+1)%Maxsize;//取模后 每次队列满的时候,取出后,下次再存便是从0开始 } /*出队列*/ public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"队列为空!!\"); } int value = array[front]; front = (front+1)%Maxsize;//取模后 每次取到队列最后一个时,便会从0开始取 return value;//取出数据 } /*打印当前队列里的信息*/ public void getall() { if (isEmpty()) { System.out.println(\"队列为空\"); } for (int i = front; i &lt;front+getsize(); i++) { //当队列一个元素在array[maxsize-1],一个在array[0]时,front=maxsize-1,getsize=2; //所以i是可能等于maxsize 甚至maxsize+1 所以要 i%Maxsize System.out.println(\"队列里的元素为:array[\"+i%Maxsize+\"]\"+array[i%Maxsize]); } } /*求有效数据个数*/ public int getsize(){ //当存了maxsize-1次(此时已经不能再存了 因为一个预留空间)时,取一个(取出一个后又可以存),再存一个(这时有数据的是1到maxsize) // 也就是说maxsize可以存数据 但必须是0号为空的前提下(最多只可以放maxsize-1个数据 这些数据可以再数组的任意连续maxsize-1个位置) // 这时rear&lt;front 所以要加maxsize return (rear+Maxsize-front)%Maxsize; } /*求数据头*/ public int gethead(){ if (isEmpty()) { System.out.println(\"队列为空\"); } return array[front]; }} 本文到此结束 感谢相遇 (●’◡’●)","link":"/2020/02/27/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"},{"title":"模拟双向链表","text":"1.模拟单链表首先要定义节点1234567891011class Node2 { public int no; public String name; public Node2 next;//指向下一个节点 public Node2 pre;//指向前一个节点 public Node2(int no, String name) { this.no = no; this.name = name; }} 2.单链表的添加2.1方式一 (不按照顺序 找到最后一个节点直接添加)12345678910111213141516/*添加节点(默认添加到最后)*/ public void addnode(Node2 node) { //创建一个辅助类指针 Node2 temp = head; //找到指针域为null的节点(最后一个节点) while (true) { if (temp.next == null) { break; } temp = temp.next; } //最后一个节点的next域指向要添加的节点 //要添加的节点的pre域指向最后一个节点 temp.next = node; node.pre = temp; } 2.2方式二(找到一个节点(next域指向的编号大于要添加的节点) 先把节点的next域复制给要添加的节点,再修改该节点的next域)1234567891011121314151617181920212223242526272829303132333435/*按照编号顺序添加节点*/ public void addnodebynum(Node2 node) { //创建一个辅助类指针 Node2 temp = head; //记录编号是否相同 boolean flag = false; //找到指针域为null的节点(最后一个节点) while (true) { if (temp.next == null) { break; } //当前的编号小于下一个节点的编号 if (node.no &lt; temp.next.no) { break; } else if (node.no == temp.next.no) { flag = true; break; } temp = temp.next; } //判断是否有相同的编号 if (flag) { System.out.println(\"编号已存在\"); } else { //1.首先改变node.next域 node.next = temp.next; node.pre = temp;//改变node的前指针 //2.判断是否是最后一个 if (temp.next !=null){ //不是则改变下一个的节点的前指针 temp.next.pre = node; } temp.next = node;//改变temp的后指针 } } 3.遍历单链表12345678910111213141516171819/*遍历所有节点(和单链表一样)*/ public void getLinkList() { //判断是否为空 if (head.next == null) { System.out.println(\"链表为空\"); return; } //辅助指针 Node2 temp = head.next; while (true) { //判断是否为最后一个节点 if (temp == null) { break; } System.out.println(temp); //后移一个 temp = temp.next; } } 4.根据编号删除节点(和根据编号增加类似)123456789101112131415161718192021222324252627/*按照编号删除节点*/ public void delnode(int no) { Node2 temp = head.next; boolean flag = false; //找到需要删除节点后自我删除 while (true) { if (temp == null) { break; } else if (temp.no == no) { //找到了待删除节点的前一个节点 flag = true; break; } temp = temp.next; } if (flag) { temp.pre.next = temp.next; //如果是最后一个节点 (如果不加这句话 当删除最后一个节点时,会报空指针(temp.next.pre)异常 因为temp.next为空没有pre) if (temp.next == null){ temp.next.pre = temp.pre; } System.out.println(\"已删除\" + no + \"节点\"); } else { System.out.println(no + \"节点没有找到\"); } } 本文到此结束 感谢相遇 (●’◡’●)","link":"/2020/02/29/%E6%A8%A1%E6%8B%9F%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"title":"模拟单链表","text":"1.模拟单链表首先要定义节点123456789101112class Node { //数据域 public int no;//编号 public String name;//名称 //指针域 public Node next;//指向下一个节点 public Node(int no, String name) { this.no = no; this.name = name; }} 2.单链表的添加2.1方式一 (不按照顺序 找到最后一个节点直接添加)1234567891011121314/*添加节点*/public void addnode(Node node) { //创建一个辅助类指针 Node temp = head; //找到指针域为null的节点(最后一个节点) while (true) { if (temp.next == null) { break; } temp = temp.next; } //最后一个节点的next域指向要添加的节点 temp.next = node;} 2.2方式二(找到一个节点(next域指向的编号大于要添加的节点) 先把节点的next域复制给要添加的节点,再修改该节点的next域)1234567891011121314151617181920212223242526272829/*按照编号顺序添加节点*/public void addnodebynum(Node node) { //创建一个辅助类指针 Node temp = head; //记录编号是否相同 boolean flag = false; //找到指针域为null的节点(最后一个节点) while (true) { if (temp.next == null) { break; } //当前的编号小于下一个节点的编号 if (node.no &lt; temp.next.no) { break; } else if (node.no == temp.next.no) { flag = true; break; } temp = temp.next; } //判断是否有相同的编号 if (flag) { System.out.println(\"编号已存在\"); } else { //1.遍历出节点的next域--&gt;新增的节点的next域 2.遍历出节点的next域指向要添加的节点 node.next = temp.next; temp.next = node; }} 3.遍历单链表12345678910111213141516171819/*遍历所有节点*/public void getLinkList() { //判断是否为空 if (head.next == null) { System.out.println(&quot;链表为空&quot;); return; } //辅助指针 Node temp = head.next; while (true) { //判断是否为最后一个节点 if (temp == null) { break; } System.out.println(temp); //后移一个 temp = temp.next; }} 4.根据编号删除节点(和根据编号增加类似)1234567891011121314151617181920212223/*按照编号删除节点*/public void delnode(int no) { Node temp = head; boolean flag = false; //找到需要删除节点的前一个节点 因为删除之后 被删除节点的前一个节点的next域需要改变 while (true) { if (temp.next == null) { break; } else if (temp.next.no == no) { //找到了待删除节点的前一个节点 flag = true; break; } temp = temp.next; } if (flag) { temp.next = temp.next.next; System.out.println(&quot;已删除&quot; + no + &quot;节点&quot;); } else { System.out.println(no + &quot;节点没有找到&quot;); }} 效果: 本文到此结束 感谢相遇 (●’◡’●)","link":"/2020/02/28/%E6%A8%A1%E6%8B%9F%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"title":"稀疏数组","text":"1.为什么要用稀疏数组？面对于含有大量相同数据的数组，可以通过稀疏数组的形式来压缩数组. 原数组中存在大量的无效数据，占据了大量的存储空间，真正有用的数据却少之又少 压缩存储可以节省存储空间以避免资源的不必要的浪费，在数据序列化到磁盘时，压缩存储可以提高IO效率 原数组 12345678910110 0 0 0 0 0 0 0 0 0 00 0 1 0 0 0 0 0 0 0 00 0 0 0 2 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 稀疏数组形式 11 11 2 1 2 1 2 4 2arr[0] [0] 表示原来的数据总行数 arr[0] [1] 表示总列数 arr[0] [2] 表示有效数据总个数 arr[1] [0] 表示第一个有效数据所在的行数 arr[1] [1] 表示第一个有效数据所在的列数 arr[1] [2] 表示第一个有效数据的值 下面的以此类推 也就是说稀疏数组的第一行表示原数组的大小 和有效数据的个数，其他的表示有效数据所在的位置和值 2.代码实现2.1.创建稀疏数组并写入数据123456789101112131415161718192021222324252627//1.首先得到原数组的有效数据的个数int sum = 0;for (int[] rows : FirstArray) { for (int row : rows) { if (row != 0) { sum++; } }}//2.1创建稀疏数组 int spareArray[][] = new int[sum + 1][3]; spareArray[0][0] = 5; spareArray[0][1] = 5; spareArray[0][2] = sum;//2.2把有效数据写进去 int count = 1; for (int i = 0; i &lt; 5; i++) { for (int j = 0; j &lt; 5; j++) { if (FirstArray[i][j] != 0) { spareArray[count][0] = i; spareArray[count][1] = j; spareArray[count][2] = FirstArray[i][j]; count++; } } } 2.2将稀疏数组写入磁盘文件中1234567891011121314151617181920/* * @Author: yxc * @date: 2020/2/23 15:10 * @Description 稀疏数组写进磁盘文件 * @parm [sparseArray] * @return void */public static void sparseArrayOutput(int[][] sparseArray) throws Exception { FileOutputStream fos = new FileOutputStream(\"F:\\\\IDEAWorkSpace\\\\JavaStudy\\\\src\\\\AMyself\\\\SparseArrayDemo.txt\"); BufferedOutputStream bos = new BufferedOutputStream(fos); for (int i = 0; i &lt; sparseArray.length; i++) { for (int j = 0; j &lt; 3; j++) { String content = String.valueOf(sparseArray[i][j]); bos.write(content.getBytes(), 0, content.getBytes().length); } } bos.flush(); bos.close();} 2.3 接下来从磁盘中读取稀疏数组123456789101112131415161718192021222324/* * @Author: yxc * @date: 2020/2/23 16:22 * @Description 把稀疏数组从磁盘文件中读取出来 * @parm [] * @return int[][] */public static int[][] sparseArrayIntput() throws Exception { FileInputStream fis = new FileInputStream(\"F:\\\\IDEAWorkSpace\\\\JavaStudy\\\\src\\\\AMyself\\\\SparseArrayDemo.txt\"); byte[] buffer = new byte[10240]; int flag = 0; int[][] sparseArray = new int[3][3]; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { //单个读取 if (flag != -1) { flag = fis.read(); int data = Integer.parseInt(String.valueOf((char) flag)); sparseArray[i][j] = data; } } } return sparseArray;} 2.4 将读取到的稀疏数组还原123456789101112131415161718 try { //接收读取到的稀疏数组 int[][] sparseArrayIntput; sparseArrayIntput = sparseArrayIntput(); //查看读取出来的数组 //openF(sparseArrayIntput); //5.还原出原数组 int chessArr2[][] = new int[sparseArrayIntput[0][0]][sparseArrayIntput[0][1]]; for (int i = 1; i &lt; sparseArrayIntput.length; i++) { chessArr2[sparseArrayIntput[i][0]][sparseArrayIntput[i][1]] = sparseArrayIntput[i][2]; } openF(chessArr2); } catch (Exception e) { e.printStackTrace(); }} 3.效果截图 本文到此结束 感谢相遇 (●’◡’●)","link":"/2020/02/23/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"title":"面试准备","text":"大学时光转瞬即逝，一不小心就面临着大四找实习。真的是失去了才懂得珍惜，面对着找工作的压力，真的时光回溯去告诉当初的自己，求求你，好好学习吧！！！现实还是要面对的，经过总结，得出复习要点以及顺序。 复习内容 1.数据结构算法 leetcode刷算法题 2.java 核心基础知识(基础语法，oo思想，集合，io,异常，泛型，反射，多线程，jdk8函数式) 3.计算机网络 (http协议 session cookie ) 4.数据库 mysql jdbc mybatis 非关系型redis缓存 5.servlet git svn 6.spring springmvc springboot 7.微服务 Dubbo spring cloud 模板技术freemarker 消息中间件 8.虚拟化技术 docker容器 9.jvm优化排错 数据库高级优化 并在学习的过程中记录所得 以加深印象 博客内容: 踩坑记录 备忘录 学习笔记 实战类环境搭建操作记录 源码分析 造轮子 工具类 本文到此结束 感谢相遇 (●’◡’●)","link":"/2020/02/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"},{"title":"模拟环形链表","text":"环形链表又叫约瑟夫环. 1.创建节点类1234567891011121314151617/*节点类*/class Node3 { //数据域 private int no; //指针域 private Node3 next; public Node3(int no) { this.no = no; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public Node3 getNext() { return next; } public void setNext(Node3 next) { this.next = next; } } 2.创建约瑟夫环123456789101112131415161718192021//添加节点构成环形链表public void addnode(int n) { if (n &lt; 1) { System.out.println(\"n的值不正确\"); return; } Node3 temp = null;//辅助指针 for (int i = 1; i &lt;= n; i++) { Node3 node = new Node3(i); if (i == 1) { first = node; first.setNext(first); temp = first;//指向第一个节点 } else { temp.setNext(node);//末尾指针指向现在的节点(末尾节点的改变) node.setNext(first);//现在的节点指向第一个节点 temp = node;//记录当前的节点(末尾指针) } }} 3.遍历节点123456789101112public void getall(){ if (first == null){ System.out.println(\"空环形列表\"); return; } Node3 temp = first; while (temp.getNext() != first){ System.out.println(temp); temp = temp.getNext(); } System.out.println(temp);} 4.出圈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//节点出圈/* * @Author: yxc * @date: 2020/3/1 17:47 * @Description 开始节点,第几次出圈,总节点 * @parm [startNo, countNum, nums] * @return void */public void outndoe(int startNo, int countNum, int nums) { // 先对数据进行校验 if (first == null || startNo &lt; 1 || startNo &gt; nums) { System.out.println(\"参数输入有误， 请重新输入\"); return; } // 创建要给辅助指针,帮助完成小孩出圈 Node3 helper = first; // 1.需要创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点 while (true) { if (helper.getNext() == first) { // 说明helper指向最后节点 break; } helper = helper.getNext(); } //2.出圈前，先让 first 和 helper 移动 startNo - 1次 (这样startNo就成为了新的first节点) for(int j = 0; j &lt; startNo - 1; j++) { first = first.getNext(); helper = helper.getNext(); } //当出圈时，让first 和 helper 指针同时 的移动 nums - 1 次, 然后出圈 //这里是一个循环操作，直到圈中只有一个节点 while(true) { if(helper == first) { //说明圈中只有一个节点 break; } //让 first 和 helper 指针同时 的移动 countNum - 1 for(int j = 0; j &lt; countNum - 1; j++) { first = first.getNext(); helper = helper.getNext(); } //这时first指向的节点，就是要出圈的小孩节点 System.out.printf(\"节点%d出圈\\n\", first.getNo()); //这时将first指向的小孩节点出圈 first = first.getNext(); helper.setNext(first); } System.out.printf(\"最后留在圈中的节点编号%d \\n\", first.getNo());} 结果 本文到此结束 感谢相遇 (●’◡’●)","link":"/2020/03/01/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"复习","slug":"复习","link":"/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"}],"categories":[{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}]}